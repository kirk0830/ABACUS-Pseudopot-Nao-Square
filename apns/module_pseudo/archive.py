import os
import re
import json
import apns.module_workflow.identifier as id
"""This is for archiving pseudopotentials element-wise.
This module should be called before test generation, as a pre-configure step.

util_scan_ returns a dictionary of pseudopotentials, element-wise, recursively including subdirectories.
"""

"""Extension for this module
Once new kind of pseudopotential is added into folder where all pseudopotentials are stored, 
update determine_kind and archive.
"""

"""Variable"""
only_scan = True

"""Functions"""
def determine_kind(folder: str):
    """even for pseudopotential generated by the same code, there are still different parameterization
    strategy. For example the ONCVPSP pseudopotential generated by Hamann et al. and Pseudojo, are
    different, so as PD series developed by PWmat team.
    
    For ADC, there are pslibrary norm-conserving, rrkjus, kjpaw, gbrv, pslnc, and even wentzvotich etc.
    
    For ATOMPAW, there are atompaw, ...
    
    However, it is impossible to deterimine the kind of pseudopotential by only looking at the contents
    of the pseudopotential file, so we need to determine the kind of pseudopotential by the folder name
    or file name, which is really a NOT ROBUST way.

    To achieve this, it is, however, necessary to download pseudopotential from the official website,
    so that at least folders are named in a expected way. Here several download links are attached:
    1. SG15: http://www.quantum-simulation.org/potentials/sg15_oncv/sg15_oncv_upf_2020-02-06.tar.gz
    2. GBRV: https://www.physics.rutgers.edu/gbrv/all_pbe_UPF_v1.5.tar.gz
    3. PSlibrary: http://theossrv1.epfl.ch/Main/Pseudopotentials
       including rrkjus, kjpaw, pslnc: http://theossrv1.epfl.ch/Main/NoBackup?action=download&upname=pbe.0.3.1.tgz
    4. DOJO: http://www.pseudo-dojo.org/
       including DOJO-v0.5 (SR): http://www.pseudo-dojo.org/pseudos/nc-sr-05_pbe_standard_upf.tgz
                 DOJO-v0.4 (FR): http://www.pseudo-dojo.org/pseudos/nc-fr-04_pbe_standard_upf.tgz
                 DOJO-v0.4 (SR): http://www.pseudo-dojo.org/pseudos/nc-sr-04_pbe_standard_upf.tgz
                 DOJO-v0.4+(SR, rare earth): http://www.pseudo-dojo.org/pseudos/nc-sr-04-3plus_pbe_standard_upf.tgz
                 DOJO-v0.3 (SR): http://www.pseudo-dojo.org/pseudos/nc-sr_pbe_standard_upf.tgz
    5. PWmat: https://www.pwmat.com/potential-download
       including PD04: https://www.pwmat.com/pwmat-resource/pseduo-download/NCPP-PD04-PBE.zip
                 PD03: https://www.pwmat.com/pwmat-resource/pseduo-download/NCPP-PD03-PBE.zip
    6. HGH: use module_pseudo/download/qespresso_official_pptable_download.py to download
    7. GTHPP1: from CP2K data
    """
    if folder.count("/") > 0:
        folder = folder.split("/")[-1]
    if folder.count("\\") > 0:
        folder = folder.split("\\")[-1]

    if folder.startswith("nc-"):
        return "dojo"
    elif folder.startswith("pbe_s_sr"):
        return "dojo"
    elif folder.startswith("NCPP-PD04"):
        return "pd04" # <- however, the real kind is pd instead of pd04
                      # pd04 is directly distinguished here due to for one element there is more than 1 pseudopotential, sometimes
    elif folder.startswith("NCPP-PD03"):
        return "pd03" # <- however, the real kind is pd instead of pd03
    elif folder.startswith("sg15"):
        return "sg15"
    elif folder.startswith("hgh"):
        return "hgh"
    elif folder.startswith("gthpp1"):
        return "gth"
    elif folder.startswith("PSEUDOPOTENTIALS"):
        return "psl"
    elif folder.startswith("GBRV_pbe_UPF"):
        return "gbrv"
    else:
        print("Current folder name is: ", folder)
        raise ValueError("Folder name not recognized, add a logic branch in this function"
                      +"\nand create a function to create description.json to describe the folder.")

def util_scan_(pseudo_dir: str, allow_skip: bool = True):
    """Returns a dictionary of pseudopotentials, element-wise.

    Args:
        pseudo_dir (str): path to the directory containing pseudopotentials

    Returns:
        dict: a dictionary of pseudopotentials, element-wise. Values are lists of pseudopotentials including path.
        list: a list contains folder in which pseudopotentials are stored.
    """
    result = {}
    folders = []
    for dir in list(os.walk(pseudo_dir)):
        # print(dir)
        # print(dir[0]) # present directory, str
        # print(dir[1]) # all subfolders names in list
        # print(dir[2]) # all files in list
        for pseudopotential in dir[2]:
            match = re.match(r"^([A-Za-z]{1,2})([-._]?.*)(.upf)$", pseudopotential, re.IGNORECASE)
            if match:
                # there is indeed upf files in present dir
                if "description.json" in dir[2] and allow_skip:
                    continue # if description.json has been already in directionary, skip
                # find dir contains pseudopotential
                element = match.group(1)[0].upper() + match.group(1)[1:].lower()
                if element not in result:
                    result[element] = []
                _dir = os.path.abspath(dir[0])
                
                result[element].append(
                    _dir+('\\' if _dir.count('\\') > 0 else '/')+pseudopotential
                )
                
                if dir[0] not in folders:
                    folder = dir[0]
                    #folder = dir[0].split("/")[-1] if dir[0].count("/") > 0 else dir[0].split("\\")[-1]
                    if folder not in folders:
                        folders.append(folder)
    return result, folders

def op_PD04_(path: str):
    """archive PD04 pseudopotentials. Becuase PD04 pseudopotential has more than 3 subsets.
    With more details, will create different subfolders and move upfs into them.
    Args:
        path (str): path of PD04 pseudopotentials
    """
    pseudopotential_kinds = {"default": []}
    path_backup = os.path.abspath(os.getcwd())
    os.chdir(path)
    files = os.listdir()
    # stage 1: find all subsets of PD04 pseudopotentials
    for file in files:
        _match = re.match(r"^([A-Za-z]{1,2})(.*\.PD04)(.*)$", file)
        if _match:
            kind = _match.group(2).replace(".PD04", "")
            element = _match.group(1)

            if kind == "":
                pseudopotential_kinds["default"].append([element, file])
            else:
                kind = kind[1:] if kind.startswith("-") else kind
                pseudopotential_kinds.setdefault(kind, []).append([element, file])

    for kind in pseudopotential_kinds.keys():
        os.mkdir(kind)
        for _, file in pseudopotential_kinds[kind]:
            os.rename(file, kind+'/'+file)
        description = {
            "kind": "pd", 
            "version": "04",
            "appendix": "" if kind == "default" else kind}
        description["files"] = {element: file for element, file in pseudopotential_kinds[kind]}
        with open(kind+'/'+"description.json", "w") as json_f:
            json.dump(description, json_f, indent=4)

    os.chdir(path_backup)

    return pseudopotential_kinds

def op_PD03_(path: str):
    """add description.json in PD03 pseudopotential folder 
    """
    path_backup = os.path.abspath(os.getcwd())
    os.chdir(path)
    fpseudos = []
    for file in os.listdir():
        _match = re.match(r"^([A-Za-z]{1,2})(.*\.PD03)(.*)$", file)
        if _match:
            element = _match.group(1)
            fpseudos.append([element, file])
    description = {"kind": "pd", "version": "03", "appendix": ""}
    description["files"] = {element: file for element, file in fpseudos}
    with open("description.json", "w") as json_f:
        json.dump(description, json_f, indent=4)
    os.chdir(path_backup)
    return description

def op_SG15_(path: str):
    """archive SG15 pseudopotentials. Becuase SG15 pseudopotential has more than 3 subsets.
    With more details, will create different subfolders and move upfs into them.
    Args:
        path (str): path of SG15 pseudopotentials
    """
    folder_and_files = {"1.0": []} # at least one version 1.0
    path_backup = os.path.abspath(os.getcwd())
    os.chdir(path)
    files = os.listdir()
    for file in files:
        _match = re.match(r"^(.*)(-)([0-9]\.[0-9])(.upf)$", file, re.IGNORECASE)
        if _match:
            element = _match.group(1)
            folder = _match.group(3)
            folder += "" if "FR" not in _match.group(1) else "_fr"
            folder_and_files.setdefault(folder, []).append([element, file])
    for folder in folder_and_files.keys():
        os.mkdir(folder)
        for _, file in folder_and_files[folder]:
            os.rename(file, folder+'/'+file)
        description = {"kind": "sg15"}
        _match = re.match(r"^([0-9]\.[0-9])(_)?(fr)?", folder)
        description["version"] = _match.group(1).replace(".", "")
        description["appendix"] = "" if not _match.group(3) else _match.group(3)
        description["files"] = {element: file for element, file in folder_and_files[folder]}
        with open(folder+'/'+"description.json", "w") as json_f:
            json.dump(description, json_f, indent=4)

    os.chdir(path_backup)

    return folder_and_files

def op_DOJO_(path: str):
    """add description.json in DOJO pseudopotential folder  
    special case: DOJO v0.3: pbe_s_sr  
    general pattern: r"^(nc-)([s|f]r)(-)([0-9]{1,2})([-_])([.*])?(_pbe_standard_upf)(.*)$"  
    """
    description = {"kind": "dojo"}
    path_backup = os.path.abspath(os.getcwd())
    folder = path.split("\\")[-1] if path.count("\\") > 0 else path.split("/")[-1]
    os.chdir(path)
    if folder == "pbe_s_sr":
        description["version"] = "03"
        description["appendix"] = ""
    else:
        _match = re.match(r"^(nc-)([sf]r)(-)([0-9]{1,2})([-_]*)(.*)(_pbe_standard)(.*)$", folder)
        if not _match:
            print("Cannot recognize arbitrary named pseudopotential folder name: ", folder)
            raise ValueError("Not standard folder name of DOJO pseudopotential.")
        if not _match.group(1).startswith("nc"):
            raise ValueError("Non norm-conserving pseudopotential is not supported by ABACUS yet.")
        description["version"] = _match.group(4)
        if _match.group(2) == "sr":
            description["appendix"] = _match.group(6)
        else:
            description["appendix"] = _match.group(2) + "_" + _match.group(6) if _match.group(6) != "" else _match.group(2)
    for file in os.listdir():
        element = file.split(".")[0]
        description.setdefault("files", {})[element] = file
    with open("description.json", "w") as json_f:
        json.dump(description, json_f, indent=4)

    os.chdir(path_backup)
    return description

def op_HGH_(path: str):
    """add description.json in HGH pseudopotential folder"""
    folder_and_files = {}
    path_backup = os.path.abspath(os.getcwd())
    os.chdir(path)
    files = os.listdir()
    for file in files:
        _match = re.match(r"^([A-Z][a-z]?)(\.pbe\-)([^\-]*)(\-)?(hgh.UPF)$", file, re.IGNORECASE)
        if _match:
            element = _match.group(1)
            folder = _match.group(3) if _match.group(3) != "" else "standard"
            folder_and_files.setdefault(folder, []).append([element, file])
    for folder in folder_and_files.keys():
        os.mkdir(folder)
        for _, file in folder_and_files[folder]:
            os.rename(file, folder+'/'+file)
        description = {"kind": "hgh", "version": folder, "appendix": ""}
        description["files"] = {element: file for element, file in folder_and_files[folder]}
        with open(folder+'/'+"description.json", "w") as json_f:
            json.dump(description, json_f, indent=4)

    os.chdir(path_backup)
    return folder_and_files

def op_GBRV_(path: str):
    """GBRV ultrasoft pseudopotential newest version is always available at:
    https://www.physics.rutgers.edu/gbrv/all_pbe_UPF_v1.5.tar.gz
    This kind of pseudopotential will be tested soon, now ABACUS supports the use of ultrasoft pseudopotential
    """
    version = path.split("_")[-1].replace("v", "").replace(".", "")
    folder_and_files = {}
    path_backup = os.path.abspath(os.getcwd())
    os.chdir(path)
    files = os.listdir()
    for file in files:
        _match = re.match(r"^([a-z]{1,2})(\_pbe\_)(.*)(v1.*)(\.uspp\.F\.UPF)$", file, re.IGNORECASE)
        if _match:
            element = _match.group(1).capitalize()
            appendix = _match.group(3)[:-1] if _match.group(3).endswith("_") else _match.group(3)
            folder_and_files.setdefault(appendix, []).append([element, file])
    for folder in folder_and_files.keys():
        _folder = folder if folder != "" else "standard"
        os.mkdir(_folder)
        for _, file in folder_and_files[folder]:
            os.rename(file, _folder+'/'+file)
        description = {"kind": "gbrv", "version": version, "appendix": folder}
        description["files"] = {element: file for element, file in folder_and_files[folder]}
        with open(_folder+'/'+"description.json", "w") as json_f:
            json.dump(description, json_f, indent=4)

    os.chdir(path_backup)
    return folder_and_files

def op_PSL_(path: str):
    """psl (pslibrary) seems only has 0.3.1 version that can be downloaded from TEHOS website:
    http://theossrv1.epfl.ch/Main/Pseudopotentials
    In this library, there are always four folders which contains different kinds of pseudopotentials:
    PSEUDOPOTENTIALS: paw and rrkjus, widely tested
    PSEUDOPOTENTIALS_ALT: paw and rrkjus, different valence configuration
    PSEUDOPOTENTIALS_NC: norm-conserving pseudopotentials
    PSEUDOPOTENTIALS_TOT: fully relativistic pseudopotentials
    
    Therefore, the pseudopotential 
    kind starts with "psl" and may be followed by "paw", "rrkjus" or "nc".
    version is "0.3.1"
    appendix might be "", "alt" or "tot"
    """
    folder_and_files = {}
    path_backup = os.path.abspath(os.getcwd())
    os.chdir(path)
    files = os.listdir()
    for file in files:
        _match = re.match(r"^([A-Z][a-z]?)(\.pbe-.*)(kjpaw|rrkjus)(_psl.*)(\.UPF)$", file, re.IGNORECASE)
        if _match:
            element = _match.group(1)
            kind = "psl" + _match.group(3)
            folder_and_files.setdefault(kind, []).append([element, file])
        _match = re.match(r"^([A-Z][a-z]?)(\.pbe)(.*)(-nc\.UPF)$", file, re.IGNORECASE)
        if _match:
            element = _match.group(1)
            kind = "pslnc"
            folder_and_files.setdefault(kind, []).append([element, file])
    # STAGE 1: standard
    if path.endswith("PSEUDOPOTENTIALS"):
        appendix = ""
    # STAGE 2: alt
    elif path.endswith("PSEUDOPOTENTIALS_ALT"):
        appendix = "alt"
    # STAGE 3: nc
    elif path.endswith("PSEUDOPOTENTIALS_NC"):
        appendix = ""
    # STAGE 4: tot
    elif path.endswith("PSEUDOPOTENTIALS_TOT"):
        appendix = "tot"
    for folder in folder_and_files.keys():
        if folder != "pslnc":
            os.mkdir(folder)
            for _, file in folder_and_files[folder]:
                os.rename(file, folder+'/'+file)
        description = {"kind": folder, "version": "031", "appendix": appendix}
        description["files"] = {element: file for element, file in folder_and_files[folder]}
        _folder = "." if folder == "pslnc" else folder
        with open(_folder+'/'+"description.json", "w") as json_f:
            json.dump(description, json_f, indent=4)
    os.chdir(path_backup)
    return folder_and_files

def op_GTH_(path: str):
    """GTH pseudopotential is developed by CP2K developers, Goedecker, Hartwigsen, Hutter and Teter
    et al. However, this kind of pseudopotential has non-diagonal element in DIJ matrices,
    which is not supported by ABACUS yet.
    """
    description = {"kind": "gth", "version": "standard", "appendix": "", "files": {}}
    path_backup = os.path.abspath(os.getcwd())
    os.chdir(path)
    files = os.listdir()
    for file in files:
        _match = re.match(r"^([A-Z][a-z]?)(\_GTH\_NC\_LnPP1\.upf)$", file, re.IGNORECASE)
        if _match:
            element = _match.group(1)
            description["files"][element] = file
    with open("description.json", "w") as json_f:
        json.dump(description, json_f, indent=4)
    os.chdir(path_backup)
    return description["files"]

def archive(pseudo_dir: str = "./download/pseudopotentials/", 
            only_scan: bool = only_scan):
    """archive pseudopotential files, will also create description.json in each folder created

    Args:
        pseudo_dir (str, optional): folder where all kinds of pseudopotentials are stored folder-by-folder. Defaults to "./download/pseudopotentials/".
        only_scan (bool, optional): if only scan without further moving upf files. Defaults to True.

    Returns:
        dict: available pseudopotentials for each element is stored in list and act as value, whose corresponding
        key is the element symbol.
    """
    if not pseudo_dir.endswith("/") and not pseudo_dir.endswith("\\"):
        pseudo_dir += "/"

    if not only_scan:
        # scan the folder and move upf files to different folders
        # files_elementwise is a dictionary, whose keys are element symbols and values are lists of upf files
        # folders is where upf files are stored
        files_elementwise, folders = util_scan_(pseudo_dir=pseudo_dir, allow_skip=True)
        # print the scan result
        for element, files in files_elementwise.items():
            print("Element: ", element, "\nFiles:\n", "\n".join(files))
        # move upf files to different folders, each kind of pseudopotential has its own archiving strategy, due to different name convention
        for folder in folders:
            folder_withpath = folder
            kind = determine_kind(folder)
            if kind == "pd04":
                op_PD04_(folder_withpath)
            elif kind == "pd03":
                op_PD03_(folder_withpath)
            elif kind == "dojo":
                op_DOJO_(folder_withpath)
            elif kind == "sg15":
                op_SG15_(folder_withpath)
            elif kind == "hgh":
                op_HGH_(folder_withpath)
            elif kind == "gth":
                op_GTH_(folder_withpath)
            elif kind == "psl":
                op_PSL_(folder_withpath)
            elif kind == "gbrv":
                op_GBRV_(folder_withpath)
            else:
                raise NotImplementedError("Folder name not recognized, add a logic branch in this function"
                      +"\nand create a function to create description.json to describe the folder.")

    # refresh the scan result
    results, folders = util_scan_(pseudo_dir=pseudo_dir, allow_skip=False)
    _description_ = {}
    for folder in folders:
        _identifier = ""
        with open(folder+"/description.json", "r") as json_f:
            _description_i = json.load(json_f)
            _identifier = id.pseudopotential(kind = _description_i["kind"], 
                                             version = _description_i["version"], 
                                             appendix = _description_i["appendix"])
        _description_[_identifier] = os.path.abspath(folder).replace("\\", "/")
    with open(pseudo_dir + "description.json", "w") as json_f:
        json.dump(_description_, json_f, indent=4)

    return results

def description(upf_path: str):
    """Get the description.json contents that generated by archive function.
    via the full path of upf file
    Args:
        upf_path (str): upf file path

    Raises:
        FileNotFoundError: description.json not generated

    Returns:
        dict: contents, dict saved in description.json
    """
    path_backup = os.path.abspath(os.getcwd())
    path = "./"
    if upf_path.count("/") > 0:
        path = "/".join(upf_path.split("/")[:-1])
    elif upf_path.count("\\") > 0:
        path = "/".join(upf_path.split("\\")[:-1])
    else:
        path = path_backup

    os.chdir(path)
    description = {}
    if os.path.isfile("description.json"):
        with open("description.json", "r") as json_f:
            description = json.load(json_f)
    else:
        print("Current directory: ", path)
        raise FileNotFoundError("description.json is not found.")

    os.chdir(path_backup)
    return description

def load(pseudo_dir: str = "./download/pseudopotentials/",
         pspot_identifier: str = "") -> dict:
    """load pseudopotential folders architecture from description.json
    if identifier is given, return the path of the pseudopotential folder
    Returns:
    >>> {
    ...    "identifier_1": "path_1",
    ...    "identifier_2": "path_2",
    ...    ...
    ... }"""
    
    pseudopot_folders_arch = {}
    if pseudo_dir[-1] == "/":
        pseudo_dir = pseudo_dir[:-1]
    with open(pseudo_dir + "/" + "description.json") as json_f:
        pseudopot_folders_arch = json.load(json_f)
    if pspot_identifier == "":
        return pseudopot_folders_arch
    elif pspot_identifier in pseudopot_folders_arch.keys():
        return pseudopot_folders_arch[pspot_identifier]
    else:
        raise ValueError("pseudopotential identifier not found.")

if __name__ == "__main__":

    print(archive(only_scan=False))