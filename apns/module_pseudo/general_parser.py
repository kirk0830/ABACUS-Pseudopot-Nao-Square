"""With Python-xml parser, provide general parser for UPF format pseudopotential"""

def preprocess(fname: str):
    """ADC pseudopotential has & symbol at the beginning of line, which is not allowed in xml, replace & with &amp;"""
    with open(fname, "r") as f:
        lines = f.readlines()
    """GBRV pseudopotential does not startswith <UPF version="2.0.1">, but <PP_INFO>, 
    add <UPF version="2.0.1"> to the beginning of the file and </UPF> to the end of the file"""
    if not lines[0].startswith("<UPF version="):
        lines.insert(0, "<UPF version=\"2.0.1\">\n")
        lines.append("</UPF>")

    with open(fname, "w") as f:
        for line in lines:
            """if line starts with &, replace & with &amp;, 
            but if already &amp;, do not replace"""
            if line.startswith("&") and not line.startswith("&amp;"):
                line = line.replace("&", "&amp;")
            f.write(line)

import re
def is_numeric_data(data):
    """judge if the data line is full of numbers (including scientific notation) separated by spaces, tabs or newlines"""
    if re.match(r"^\s*[+-]?\d+(\.\d*)?([eE][+-]?\d+)?(\s+[+-]?\d+(\.\d*)?([eE][+-]?\d+)?)*\s*$", data):
        return True
    else:
        return False

def decompose_data(data):
    """to decompose all numbers in one line, but need to judge whether int or float"""
    if re.match(r"^\s*[+-]?\d+(\.\d*)([eE][+-]?\d+)?(\s+[+-]?\d+(\.\d*)([eE][+-]?\d+)?)*\s*$", data):
        return [float(x) for x in data.split()] if " " in data else float(data.strip())
    elif re.match(r"^\s*[+-]?\d+(\s+[+-]?\d+)*\s*$", data):
        return [int(x) for x in data.split()] if " " in data else int(data.strip())
    else:
        raise ValueError("data is not numeric")

def postprocess(parsed: dict):

    for section in parsed:
        """first the data"""
        if parsed[section]["data"] is not None:
            parsed[section]["data"] = parsed[section]["data"].strip()
            if is_numeric_data(parsed[section]["data"]):
                parsed[section]["data"] = decompose_data(parsed[section]["data"])
        """then the attributes"""
        if parsed[section]["attrib"] is not None:
            for attrib in parsed[section]["attrib"]:
                parsed[section]["attrib"][attrib] = parsed[section]["attrib"][attrib].strip()
                if is_numeric_data(parsed[section]["attrib"][attrib]):
                    parsed[section]["attrib"][attrib] = decompose_data(parsed[section]["attrib"][attrib])
                elif parsed[section]["attrib"][attrib] == "T":
                    parsed[section]["attrib"][attrib] = True
                elif parsed[section]["attrib"][attrib] == "F":
                    parsed[section]["attrib"][attrib] = False
    return parsed

import json
import xml.etree.ElementTree as ET

def iter_tree(root: ET.Element):
    """iterate through the tree, return a dictionary flattened from the tree"""
    return {child.tag: {"attrib": child.attrib, "data": child.text} for child in list(root.iter())}

def parse(fname: str):
    preprocess(fname)
    tree = ET.ElementTree(file=fname)
    root = tree.getroot()
    parsed = iter_tree(root)
    parsed = postprocess(parsed)
    return parsed

def parse_to_json(fname: str):
    parsed = parse(fname)
    with open(fname[:-4]+'.json', 'w') as f:
        json.dump(parsed, f, indent=4)

def determine_type(parsed: dict):
    """pseudopotentials can be generated by not only one codes, to extract information 
    from PP_INFO, PP_INPUTFILE, need to know the exact way how information is organized
    """

    """ONCVPSP
    ONCVPSP is the format of pseudopotential most seen in norm-conserving pseudopotential,
    such as SG15, PD (developed by pwmat team?) and DOJO"""
    if "ONCVPSP" in parsed["PP_INFO"]["data"]:
        return "ONCVPSP"
    if "ONCVPSP" in parsed["PP_HEADER"]["attrib"]["generated"]:
        return "ONCVPSP"

    """ADC
    ADC is the format of pseudopotential collected in pslibrary, including
    pslnc, rrkjus and kjpaw, most collected in QE website the pptable"""
    if "ADC" in parsed["PP_INFO"]["data"]:
        return "ADC"
    if "ADC" in parsed["PP_HEADER"]["attrib"]["generated"]:
        return "ADC"
    if "ADC" in parsed["PP_HEADER"]["attrib"]["author"]:
        return "ADC"
    
    """GTH
    this is the kind developed by CP2K developers, Goedecker, Hartwigsen, Hutter and Teter
    et al. However, this kind of pseudopotential has non-diagonal element in DIJ matrices,
    which is not supported by ABACUS yet."""
    if "Goedecker/Hartwigsen/Hutter/Teter" in parsed["PP_HEADER"]["attrib"]["author"]:
        return "GTH"
        raise NotImplementedError("GTH pseudopotential is not supported by ABACUS yet because of non-diagonal DIJ matrices")
    
    """GBRV
    It is one of the most efficient pseudopotential presently, ABACUS pw supports this kind
    of pseudopotential, ABACUS lcao not yet.
    """
    if "Generated using Vanderbilt code" in parsed["PP_INFO"]["data"]:
        return "GBRV"

    """ATOMPAW
    atompaw looks like ADC but not quite the same in occupation information
    Comparatively the uni_marburg is actually more similar to ADC"""
    if "ATOMPAW" in parsed["PP_INFO"]["data"]:
        return "ATOMPAW"
    if "ATOMPAW" in parsed["PP_HEADER"]["attrib"]["generated"]:
        return "ATOMPAW"
    
    raise ValueError("Pseudopotential type not recognized")

def valelec_config(fname: str):
    """extract valence electron configuration from pseudopotential file
    return a list of lists, 
    [
        ["1s", "2s"] # for s
        ["2p"] # for p
        ["3d"] # for d
        ["4f"] # for f
    ]"""
    parsed = parse(fname)
    pseudo_type = determine_type(parsed)
    if pseudo_type == "ONCVPSP":
        import apns.module_pseudo.special_parser.ONCVPSP_D_R_Hamann as ONCV_parser
        return ONCV_parser.valelec_config(parsed)
    elif pseudo_type == "ADC":
        import apns.module_pseudo.special_parser.Atomic_A_Dal_Corso as ADC_parser
        return ADC_parser.valelec_config(parsed)
    elif pseudo_type == "GBRV":
        import apns.module_pseudo.special_parser.GBRV_Vanderbilt as GBRV_parser
        return GBRV_parser.valelec_config(parsed)
    elif pseudo_type == "ATOMPAW":
        import apns.module_pseudo.special_parser.ATOMPAW_wentzcovitch as ATOMPAW_parser
        return ATOMPAW_parser.valelec_config(parsed)
    elif pseudo_type == "GTH":
        raise ValueError("GTH pseudopotential does not have valence electron configuration information")
    else:
        raise ValueError("Pseudopotential type not recognized")

import numpy as np
def is_compatible(fname: str, software: str = "abacus"):
    """presently the compatibility is determined by DIJ matrices,
    this function will be called at the very beginning of APNS run workflow"""
    parsed = parse(fname)
    if software == "abacus":
        return compatible_with_abacus(parsed)
    elif software == "qespresso":
        return compatible_with_qespresso(parsed)
    else:
        raise ValueError("Software not recognized")

def compatible_with_abacus(parsed: dict):

    pseudo_type = determine_type(parsed)
    if pseudo_type == "GBRV":
        """GBRV uses DIJ in format like:
        12                  Number of nonzero Dij
        irow        icol        value
        ...

        Therefore as long as the first and second column are not equal, it is not compatible
        """
        dij = parsed["PP_DIJ"]["data"]
        lines = [line.strip() for il, line in enumerate(dij.split("\n")) if il > 0]
        for line in lines:
            if line.split()[0] != line.split()[1]:
                return False
    else:
        """other pseudopotentials use DIJ in format like an array, so need to get number_of_proj
        from PP_HEADER to get the number of rows and columns of DIJ matrix
        """
        number_of_proj = parsed["PP_HEADER"]["attrib"]["number_of_proj"]
        dij = parsed["PP_DIJ"]["data"]
        dij = np.reshape(dij, newshape=(number_of_proj, -1))
        """all non-diagonal elements should be zero"""
        for i in range(number_of_proj):
            for j in range(number_of_proj):
                if i != j and dij[i, j] != 0:
                    return False
    return True

def compatible_with_qespresso(parsed: dict):

    pseudo_type = determine_type(parsed)
    return True

if __name__ == "__main__":
    directory = './download/pseudopotentials/hgh/'
    fname = "Al.pbe-hgh.UPF"
    #parse_to_json(directory+fname)
    #print(is_compatible(directory + fname))
    pseudopot = iter_tree(directory+fname)
    import json
    with open(directory+fname[:-4]+'.json', 'w') as f:
        json.dump(pseudopot, f, indent=4)