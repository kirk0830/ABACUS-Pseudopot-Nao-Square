"""this file provides advanced functions for greping various kinds of information from pseudopotential files"""
import apns.pspot.parse_kernel.api as ampka
import numpy as np

#######################################
# Basic utilities for pseudopotential #
#######################################
def as_dict(pseudopotential: str|dict):
    """convert pseudopotential file to dictionary"""
    if isinstance(pseudopotential, str):
        return ampka.parse(pseudopotential)
    elif isinstance(pseudopotential, dict):
        return pseudopotential
    else:
        raise ValueError("Pseudopotential type not recognized")

#######################################
#         Advanced utilities          #
#######################################
def determine_code(pseudopotential: str|dict):
    """pseudopotentials can be generated by not only one codes, to extract information 
    from PP_INFO, PP_INPUTFILE, need to know the exact way how information is organized.

    Possible return values:
    "ONCVPSP", "ADC", "GTH", "GBRV", "ATOMPAW"
    """
    parsed = as_dict(pseudopotential)
    """ONCVPSP: Optimized Norm-Conserving Vanderbilt Pseudopotential, developed by Hamann et al.
    ONCVPSP is the format of pseudopotential most seen in norm-conserving pseudopotential,
    such as SG15, PD (developed by PWmat team) and DOJO"""
    if "ONCVPSP" in parsed["PP_INFO"].get("data", []):
        return "ONCVPSP"
    if "ONCVPSP" in parsed["PP_HEADER"]["attrib"].get("generated", ""):
        return "ONCVPSP"

    """ADC: Atomic code developed by Dal Corso et al.
    ADC is the format of pseudopotential collected in pslibrary, including
    pslnc, rrkjus and kjpaw, most collected in QE website the pptable"""
    if "ADC" in parsed["PP_INFO"].get("data", []):
        return "ADC"
    if "ADC" in parsed["PP_HEADER"]["attrib"].get("generated", ""):
        return "ADC"
    if "ADC" in parsed["PP_HEADER"]["attrib"].get("author", ""):
        return "ADC"
    if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_INFO"].get("data", []):
        return "ADC"
    if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_HEADER"]["attrib"].get("generated", ""):
        return "ADC"
    if "Generated using \"atomic\" code by A. Dal Corso" in parsed["PP_HEADER"]["attrib"].get("author", ""):
        return "ADC"
    
    """GTH: Goedecker-Hartwigsen-Hutter-Teter
    this is the kind developed by CP2K developers, Goedecker, Hartwigsen, Hutter and Teter
    et al. However, this kind of pseudopotential has non-diagonal element in DIJ matrices,
    which is not supported by ABACUS yet."""
    if "Goedecker/Hartwigsen/Hutter/Teter" in parsed["PP_HEADER"]["attrib"].get("author", ""):
        return "GTH"
        raise NotImplementedError("GTH pseudopotential is not supported by ABACUS yet because of non-diagonal DIJ matrices")
    
    """GBRV: Garrity-Bennett-Rabe-Vanderbilt
    It is one of the most efficient pseudopotential presently, ABACUS pw supports this kind
    of pseudopotential, ABACUS lcao not yet.
    """
    if "Generated using Vanderbilt code" in parsed["PP_INFO"].get("data", []):
        return "GBRV"
    if "Opium" in parsed["PP_INFO"].get("data", []):
        # the pseudopotential generated by Opium is actually the UPF1 format
        # in the future we will change the so-called GBRV foramt to UPF1.
        return "GBRV"

    """ATOMPAW
    atompaw looks like ADC but not quite the same in occupation information
    Comparatively the uni_marburg is actually more similar to ADC"""
    if "ATOMPAW" in parsed["PP_INFO"].get("data", []):
        return "ATOMPAW"
    if "ATOMPAW" in parsed["PP_HEADER"]["attrib"].get("generated", ""):
        return "ATOMPAW"
    
    raise ValueError(f"Pseudopotential type not recognized: {parsed['PP_INFO']['data']}")

def valence(pseudopotential: str|dict):
    """extract valence electron configuration from pseudopotential file
    return a list of lists, 
    [
        ["1s", "2s"] # for s
        ["2p"] # for p
        ["3d"] # for d
        ["4f"] # for f
    ]"""
    parsed = as_dict(pseudopotential)
    pseudo_type = determine_code(parsed)
    if pseudo_type == "ONCVPSP":
        import apns.pspot.parse_special.ONCVPSP_D_R_Hamann as ONCV_parser
        return ONCV_parser.valence(parsed)
    elif pseudo_type == "ADC":
        import apns.pspot.parse_special.Atomic_A_Dal_Corso as ADC_parser
        return ADC_parser.valence(parsed)
    elif pseudo_type == "GBRV":
        import apns.pspot.parse_special.GBRV_Vanderbilt as GBRV_parser
        return GBRV_parser.valence(parsed)
    elif pseudo_type == "ATOMPAW":
        import apns.pspot.parse_special.ATOMPAW_wentzcovitch as ATOMPAW_parser
        return ATOMPAW_parser.valence(parsed)
    elif pseudo_type == "GTH":
        raise ValueError("GTH pseudopotential does not have valence electron configuration information")
    else:
        raise ValueError("Pseudopotential type not recognized")

def is_compatible(pseudopotential: str|dict, software: str = "abacus"):
    """presently the compatibility is determined by DIJ matrices,
    this function will be called at the very beginning of APNS run workflow"""
    parsed = as_dict(pseudopotential)
    print("Compatibility check for pseudopotential for software: ", software)
    print("Number of valence treated electrons: ", parsed["PP_HEADER"]["attrib"]["z_valence"])
    if software == "abacus":
        return is_compatible_with_abacus(parsed)
    elif software == "qespresso":
        return is_compatible_with_qespresso(parsed)
    else:
        raise ValueError("Software not recognized")

def z_valence(pseudopotential: str|dict):
    """extract valence electron number from pseudopotential file"""
    
    parsed = as_dict(pseudopotential)
    pptype = determine_code(parsed)
    if pptype == "GBRV":
        from apns.pspot.parse_special.GBRV_Vanderbilt import PP_HEADER as gbrv_header
        return gbrv_header(parsed["PP_HEADER"]["data"])["attrib"]["z_valence"]
    return parsed["PP_HEADER"]["attrib"]["z_valence"]

#######################################
#auxiliary functions for compatibility#
#######################################
def is_compatible_with_abacus(parsed: dict):

    pseudo_type = determine_code(parsed)
    if pseudo_type == "GBRV":
        """GBRV uses DIJ in format like:
        12                  Number of nonzero Dij
        irow        icol        value
        ...

        Therefore as long as the first and second column are not equal, it is not compatible
        """
        dij = parsed["PP_DIJ"]["data"]
        lines = [line.strip() for il, line in enumerate(dij.split("\n")) if il > 0]
        for line in lines:
            if line.split()[0] != line.split()[1]:
                return False
    else:
        """other pseudopotentials use DIJ in format like an array, so need to get number_of_proj
        from PP_HEADER to get the number of rows and columns of DIJ matrix
        """
        number_of_proj = parsed["PP_HEADER"]["attrib"]["number_of_proj"]
        dij = parsed["PP_DIJ"]["data"]
        dij = np.reshape(dij, newshape=(number_of_proj, -1))
        """all non-diagonal elements should be zero"""
        for i in range(number_of_proj):
            for j in range(number_of_proj):
                if i != j and dij[i, j] != 0:
                    return False
    return True

def is_compatible_with_qespresso(parsed: dict):

    pseudo_type = determine_code(parsed)
    # actually Quantum Espresso can support even all kinds of pseudopotentials
    return True
