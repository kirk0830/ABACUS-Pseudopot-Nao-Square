class StructureManager:
    """# StructureManager
    structure manager is for managing structures, including downloading, generating, etc.
    
    See unittest for its usage. Most of time it is easy:
    ```python
    sm = StructureManager() # but can also describe structures at this step
    ```
    The second step is to describe the structures, which is to provide the information of the
    structures, including the type of the structure, the parameters of the structure, the
    pseudopotentials and numerical atomic orbitals used in the structure.
    - The type of the structure can be 'cif', 'bravis', 'molecule'.
    - The second arg is a tuple composed of fname of cif file or the name of the structure,
    then if provided, the magnetic moment of EACH atom in the structure.
    - The third arg is a list of scalings, which will be used to scale the structure, will be
    useful when doing EOS and varying bond lengths.
    - Pseudopotentials and numerical atomic orbitals will be searched by tags specified.

    ```python
    desc = [(
                'cif',
                ('/root/abacus-develop/ABACUS-Pseudopot-Nao-Square/download/structures/Si.cif',
                [0.00, 1.00]),
                [0.95, 0.97, 0.99, 1.01, 1.03], 
                {"Si": ['PBE', 'NC', 'sg15', 'sr']}, 
                {"Si": ['6au', '100Ry' , '2s2p1d']}
            ),
            (
                'bravis',
                ('SiO_xy2', None), 
                [0.95, 0.97, 0.99, 1.01, 1.03], 
                {"Si": ['PBE', 'NC', 'sg15', 'sr'], "O": ['PBE', 'US', 'GBRV', '1.4']}, 
                None
            ),
            (
                'molecule',
                ('Ba_dimer', None), 
                [1.0, 1.02, 1.04, 1.06, 1.08], 
                {"Ba": ['PBE', 'NC', 'sg15', 'sr']}, 
                {"Ba": ['6au', '100Ry' , '2s2p1d']}
            )]
    sm.describe(desc) # enough information has been provided to build the structures
    ```
    then to build the structures, according to the description
    ```python
    sm.build(pseudo_dir, orbital_dir)
    ```
    at this step, all structures have been built, along with their AtomSpecies, can be
    accessed by `sm.structures`

    Then export the structures to the abacus input file
    ```python
    result = sm.export(fmt='abacus')
    ```
    if the `save` is not None, then the result will be saved to the file, otherwise
    result will contain the content of files.

    `StructureManager` allows decoupling between the DFT calculation setting and the structure
    definition.
    """
    # descriptors of structures
    desc: list[tuple[str, str, list[float], list[str], list[str]|None]] = []
    # structures generated
    structures: list[tuple[Cell, list[AtomSpecies]]] = []

    def idtfr_gen(the_second: str) -> str:
        """generate the identifier of the structure from the second arg of the descriptor"""
        import os
        if os.path.exists(the_second) and os.path.isfile(the_second) and the_second.endswith(".cif"):
            return "cif", the_second
        import re
        match_ = re.match(r'^([A-Z][a-z]?)_(sc|bcc|fcc|diamond)$', the_second)
        if match_:
            return "bravis", *match_.groups()
        match_ = re.match(r'^([A-Z][a-z]?[A-Z][a-z]?)_(xy2|xy3|x2y|x2y3|x2y5)$', the_second)
        if match_:
            return "bravis", *match_.groups()
        match_ = re.match(r'^([A-Z][a-z]?)_(dimer|trimer|tetramer)$', the_second)
        if match_:
            return "molecule", *match_.groups()
        return None

    def atomsets_transpose(atomsets: list):
        # transpose atomsets from {atom: [[pptags...], [naotags...]]} to [{atom: [pptags...]}, {atom: [naotags...]}]
        atomsets = [[{key: value[i] for key, value in atomset.items()} for i in range(len(next(iter(atomset.values()))))]
                    for atomset in atomsets]
        # for each atomset, there are two dicts, if all values of dict is None, then set the dict as None
        atomsets = [[None if all([value is None for value in tags.values()]) else tags for tags in atomset] for atomset in atomsets]
        return atomsets

    def make_desc(atomsets: list, structures: list):
        """
        iterate on the `structures` section in input, in-on-shot download all structures
        needed, and return the descriptors of the structures for calling `describe()`.
        This function is called like:
        ```python
        atomsets = inp["atomsets"]
        structures = inp["structures"]
        desc = StructureManager.make_desc(atomsets, structures)
        ```
        """
        from apns.module_structure.api import download
        api_keys = {}
        formula = {}
        db_formula_isid_map = {}
        for is_, s in enumerate(structures):
            db = s.get("database", "mp") # default structure database is Materials Project
            for id_, d in enumerate(s["desc"]):
                if d[0] == "search":
                    api_keys[db] = s.get("api_key", "")
                    formula.setdefault(db, []).append(d[1])
                    db_formula_isid_map.setdefault((db, d[1]), []).append((is_, id_))
        # should add local check to avoid download the same structure!
        log = download(api_keys=api_keys, formula=formula) # will be nested dict of list of tuples, [db][formula][icif] = (fname, magmoms)
        atomsets = StructureManager.atomsets_transpose(atomsets)
        # first convert not cif structures to descriptors
        desc_ = [[("cif" if d[0] == "local" else StructureManager.idtfr_gen(d[1])[0], (d[1], None), d[2], 
             atomsets[s["atomset"]][0], atomsets[s["atomset"]][1]) for d in s["desc"] if d[0] != "search"] for s in structures] 
        # then add those downloaded structures to the descriptors
        for db, search_results in log.items(): # for each database, their formulas would also be dict, keys are formula, values are list of tuples
            for formula, result in search_results.items(): # result is a list of tuples, each tuple is (fname, magmoms)
                for is_, id_ in db_formula_isid_map[(db, formula)]:
                    desc_[is_].extend([("cif", (fname, magmoms), structures[is_]["desc"][id_][2], atomsets[s["atomset"]][0], atomsets[s["atomset"]][1])
                        for fname, magmoms in result])
        return desc_

    def __init__(self, desc: list = None) -> None:
        """structure can be imported at the initialization of the structure manager,
        but can also be imported/overwritten later if call the describe() method."""
        if desc is not None:
            self.describe(desc)
    
    """fucntions in this part is for importing structures without additional scalling, say
    not for EOS, not for varying bond lengths, ..."""
    def describe(self, desc, overwrite: bool = True):
        """
        For lazy build. First describe, then build explicitly and output instantly.
        : if the cell can be built with several parameters, then those parameters are
        representation of those exact structures. Calculate on those parameters means
        to vary and generate structures.
        
        ```python
        # descriptor
        #        identifier               str                         list[float]                    list[str] list[str]
        # (cif/bravis/molecule, (fcif/X_sc/X_dimer, magmoms), EOS_scalings/EOS_scalings/bond_lengths, pptags,   naotags)
        # pptags and naotags are associated.
        # once from pptags determines a list of pseudopotentials, 
        # for each pseudopotential, search numerical atomic orbital according to naotags.
        # example
        desc = [(
                    'cif',
                    ('/root/abacus-develop/ABACUS-Pseudopot-Nao-Square/download/structures/Si.cif',
                    [0.00, 1.00]),
                    [0.95, 0.97, 0.99, 1.01, 1.03], 
                    {"Si": ['PBE', 'NC', 'sg15', 'sr']}, 
                    {"Si": ['6au', '100Ry' , '2s2p1d']}
                ),
                (
                    'bravis',
                    ('SiO_xy2', None), 
                    [0.95, 0.97, 0.99, 1.01, 1.03], 
                    {"Si": ['PBE', 'NC', 'sg15', 'sr'], "O": ['PBE', 'US', 'GBRV', '1.4']}, 
                    None
                ),
                (
                    'molecule',
                    ('Ba_dimer', None), 
                    [1.0, 1.02, 1.04, 1.06, 1.08], 
                    {"Ba": ['PBE', 'NC', 'sg15', 'sr']}, 
                    {"Ba": ['6au', '100Ry' , '2s2p1d']}
                )]
        sm = StructureManager()
        sm.describe(desc)
        ```
        """
        assert isinstance(desc, list), f'desc should be a list: {desc}'
        assert all([isinstance(d, tuple) for d in desc]), f'each element in desc should be a tuple: {desc}'
        assert all([len(d) == 5 for d in desc]), f'each element in desc should be a tuple of 5 elements: {desc}'
        assert all([isinstance(d[0], str) and d[0] in ['cif', 'bravis', 'molecule'] for d in desc]), \
            f'identifier should be cif, bravis or molecule: {desc}'
        assert all([isinstance(d[1], tuple) and len(d[1]) == 2 for d in desc])
        assert all([isinstance(d[1][0], str) and (isinstance(d[1][1], list) or d[1][1] is None) for d in desc])
        assert all([isinstance(d[1][0], str) and StructureManager.idtfr_gen(d[1][0])[0] in ["cif", "bravis", "molecule"]
                    for d in desc]), f'descriptor is neither a cif file nor a bravis/molecule type: {desc}'
        assert all([isinstance(d[2], list) and all([isinstance(x, float) for x in d[2]]) for d in desc]), \
            f'characteristic scaling should be list of floats: {desc}'
        assert all([isinstance(d[3], dict) and all([all([isinstance(tag, str) for tag in tags]) for tags in d[3].values()]) for d in desc]), \
            f'pptags should be dict of lists of strings: {desc}'
        assert all([\
            (isinstance(d[4], dict) and all([all([isinstance(tag, str) for tag in tags]) for tags in d[4].values])) or (d[4] is None) \
                for d in desc]), f'naotags should be dict of lists of strings: {desc} or None in basis_type pw calculation'
        self.desc = desc if overwrite else self.desc + desc
        """will add replace, pop and append functionalities later"""
    
    def build(self, pseudo_dir: str, orbital_dir: str):
        """expand all tests, this function is unique in APNS, but should not appear in
        ABACUS newly-refactored UnitCell module, becuase StructureManager is not exactly
        the StructureIterator or something, while it is less necessary to implement such
        a class or function."""
        import itertools as itools
        lcao = [d[4] for d in self.desc if d[4] is not None]
        assert len(lcao) == 0 or len(lcao) == len(self.desc), f'naotags should be all None or all not None: {lcao}'
        lcao = (len(lcao) != 0)
        # print(f"Build {len(self.desc)} structures for ABACUS-LCAO calculation: {lcao}")
        self.structures = [] # everytime refresh all structures?
        for idtfir, stru, scales, pptags, naotags in self.desc: # for each structure prototype
            proto = Cell()
            config, magmom = stru
            proto.build(idtfir, config, 1.0) # leaves d[3] the pptags and d[4] the naotags apart
            on_the_fly_species = [AtomSpecies(symbol) for symbol in proto.kinds] # it is the way how AtomSpecies bind with Cell
            pptags = [pptags[k] for k in proto.kinds]
            for i, s in enumerate(on_the_fly_species): s.set_pp(pseudo_dir, pptags[i])
            pps_scale_comb = [s.pp for s in on_the_fly_species] + [scales]
            assert pps_scale_comb is not None, f'pps_scale_comb should not be None: {pps_scale_comb}'
            pps_scale_comb = list(itools.product(*pps_scale_comb))
            for pps_scale in pps_scale_comb:
                pps, scale = pps_scale[:-1], pps_scale[-1]
                specific = Cell()
                specific.build(idtfir, config, scale)
                specific.divide_subset(magmom)
                for i, s in enumerate(on_the_fly_species): s.pp = pps[i] # inject the pseudopotentials
                naotags = None if not lcao else [naotags[k] for k in proto.kinds]
                for s in on_the_fly_species: s.set_nao(pps, orbital_dir, naotags)
                naos_comb = [s.nao for s in on_the_fly_species]
                assert naos_comb is not None, f'naos_comb should not be None: {naos_comb}'
                naos_comb = list(itools.product(*naos_comb)) if lcao else [None]
                for naos in naos_comb:
                    for i, s in enumerate(on_the_fly_species): s.nao = naos[i] if lcao else None # inject the numerical atomic orbitals
                    self.structures.append((specific, on_the_fly_species))

    def export(self, fmt: str = "abacus", save: str = None):
        """export the structures to files. If save is given, the the value given to save would be the prefix.
        Return list of tuple of three strings, if save is specified, then return the file name, otherwise the
        content of the files. The first string is the structure file, the second is the kline file, and the third
        is the kpt file. The content of the files are in the order of the structures."""
        import uuid
        result = []
        assert fmt == "abacus", f'fmt should be abacus: {fmt}'
        for s in self.structures:
            assert isinstance(s[0], Cell) and isinstance(s[1], list) and all([isinstance(x, AtomSpecies) for x in s[1]]), \
                f'structure should be a tuple of Cell and list of AtomSpecies.'
            stru = StructureManager.write_abacus_stru(s[0], s[1])
            kline, kpt = StructureManager.write_abacus_kpt(s[0])
            if save is not None:
                stamp = uuid.uuid4().hex
                fstru, fkline, fkpt = f"{stamp}.STRU", f"{stamp}.KLINE", f"{stamp}.KPT"
                with open(fstru, "w") as f: f.write(stru)
                with open(fkline, "w") as f: f.write(kline if kline is not None else "")
                with open(fkpt, "w") as f: f.write(kpt)
                result.append((fstru, fkline, fkpt))
            else:
                result.append((stru, kline, kpt))
        return result
    #######################
    #      utilities      #
    #######################
    def write_abacus_stru(cell: Cell, species: list[AtomSpecies]):
        """write a single ABACUS STRU file with Cell and list of AtomSpecies instances"""
        assert max(cell.labels_kinds_map) + 1 == len(species), f'cell.labels_kinds_map should be consistent with species. {cell.labels_kinds_map} vs {len(species)}'
        result = "ATOMIC_SPECIES\n"
        for label in list(dict.fromkeys(cell.labels)):
            s = species[cell.labels_kinds_map[cell.labels.index(label)]]
            fpp = s.pp.replace("\\", "/").split("/")[-1]
            result += f"{label:4s} {s.mass:8.4f} {fpp}\n"
        if all([s.nao is not None for s in species]):
            result += "\nNUMERICAL_ORBITAL\n"
            for label in list(dict.fromkeys(cell.labels)):
                s = species[cell.labels_kinds_map[cell.labels.index(label)]]
                result += s.nao.replace("\\", "/").split("/")[-1] + "\n"
        # else:
        #     print(f"Warning: not all species have numerical atomic orbitals, ignore if PW calculation")
        result += f"\nLATTICE_CONSTANT\n{cell.lat0:<20.10f}\n"
        result += f"\nLATTICE_VECTOR\n"
        latv = Cell._abc_angles_to_vec([cell.a, cell.b, cell.c, cell.alpha, cell.beta, cell.gamma], True)
        for i in range(3):
            result += f"{latv[i][0]:<20.10f} {latv[i][1]:<20.10f} {latv[i][2]:<20.10f}\n"
        result += f"\nATOMIC_POSITIONS\n"
        result += "Cartesian_angstrom\n" if not cell.periodic else "Direct\n"
        for label in list(dict.fromkeys(cell.labels)):
            ias = [il for il, lbl in enumerate(cell.labels) if lbl == label] # indices of atoms with the same label
            result += f"{label}\n{cell.magmoms[ias[0]]:<4.2f}\n{len(ias)}\n"
            for j in ias:
                result += f"{cell.coords[j][0]:<20.10f} {cell.coords[j][1]:<20.10f} {cell.coords[j][2]:<20.10f} m "
                result += f"{cell.mobs[j][0]:<1d} {cell.mobs[j][1]:<1d} {cell.mobs[j][2]:<1d}\n"
        return result

    def write_abacus_kpt(cell: Cell):
        """write both KLINE and KPT file with Cell"""
        if cell.possible_kpath is not None and cell.sym_ks is not None:
            nks_each = 20
            nks_tot = len(cell.possible_kpath) * nks_each + 1
            kline = f"KPOINTS\n{nks_tot}\nLine\n"
            # merge all consecutive segments connecting high symmetrical kpoints
            segs = []
            for seg in cell.possible_kpath:
                b, e = seg
                if not segs or b != segs[-1][-1]:
                    segs.append([b, e])
                else:
                    segs[-1].append(e)

            for seg in segs:
                for ik, k in enumerate(seg):
                    nks = nks_each if ik != len(seg) - 1 else 1
                    kline += f"{cell.sym_ks[k][0]:13.10f} {cell.sym_ks[k][1]:13.10f} {cell.sym_ks[k][2]:13.10f} {nks}\n"
        else:
            kline = None
        kpt = f"KPOINTS\n0\nGAMMA\n"
        kpt += f"{cell.mpmesh_nks[0]:<d} {cell.mpmesh_nks[1]:<d} {cell.mpmesh_nks[2]:<d} 0 0 0\n"
        return kline, kpt


class TestStructureManager(unittest.TestCase):

    def test_atomsets_transpose(self):
        atomsets = [
            {"H": [["pptagH1", "pptagH2"], None],
             "O": [["pptagO1", "pptagO2"], None]},
        ]
        result = StructureManager.atomsets_transpose(atomsets)
        self.assertEqual(result, [[{'H': ['pptagH1', 'pptagH2'], 'O': ['pptagO1', 'pptagO2']}, None]])

    def est_make_desc(self):
        atomsets = [
            {"H": [["pptagH1", "pptagH2"], None],
             "O": [["pptagO1", "pptagO2"], None]},
        ]
        structures = [
            {"database": "mp",
            "atomset": 0, 
            "api_key": "wV1HUdmgESPVgSmQj5cc8WvttCO8NTHp", "desc": [
            ["search", "BaTiO3", [1.0]]
            ]}
        ]
        result = StructureManager.make_desc(
            atomsets, structures
        )
        ref = [[('cif', ('apns_cache/mp-5777.cif', [0.0, 0.0, 0.0, 0.0, 0.0]), [1.0], 
                 {'H': ['pptagH1', 'pptagH2'], 'O': ["pptagO1", "pptagO2"]}, None)]]
        self.assertEqual(result, ref)

    def test_describe_re(self):
        """regular expression in StructureManager.build function"""
        import re
        _re = r'([A-Z][a-z]?_[dimer|trimer|tetramer|sc|bcc|fcc|diamond])|([A-Z][a-z]?[A-Z][a-z]?_[xy2|xy3|x2y|x2y3|x2y5])'
        _match = re.match(_re, 'Si_dimer')
        self.assertIsNotNone(_match)
        _match = re.match(_re, 'O_sc')
        self.assertIsNotNone(_match)
        _match = re.match(_re, 'SiO_xy2')
        self.assertIsNotNone(_match)
        _match = re.match(_re, 'SiO_x2y5')
        self.assertIsNotNone(_match)
        _match = re.match(_re, 'SiO_x2y')
        self.assertIsNotNone(_match)
        _match = re.match(_re, 'CO_x2y3')
        self.assertIsNotNone(_match)
        _match = re.match(_re, 'Si_x2y3')
        self.assertIsNone(_match)
        _match = re.match(_re, 'SiO_x2y3')
        self.assertIsNotNone(_match) # indicating preset Si2O3 structure
        _match = re.match(_re, 'SiO_diamond')
        self.assertIsNone(_match) # SiO2 in diamond-like Bravis lattice is not defined in this way

    def test_idtfr_gen(self):
        self.assertEqual(StructureManager.idtfr_gen('Si_dimer'), ('molecule', 'Si', 'dimer'))
        self.assertEqual(StructureManager.idtfr_gen('SiO_xy2'), ('bravis', 'SiO', 'xy2'))
        self.assertEqual(StructureManager.idtfr_gen('SiO_x2y3'), ('bravis', 'SiO', 'x2y3'))
        self.assertIsNone(StructureManager.idtfr_gen('SiO_diamond'))
        fcif = "Si.cif"
        with open(fcif, "w") as f:
            f.write("fake cif")
        self.assertEqual(StructureManager.idtfr_gen(fcif), ('cif', fcif))
        import os
        os.remove(fcif)

    def test_build(self):
        import os
        sm = StructureManager()
        # test Bravis lattice
        sm.describe([('bravis', ('Si_diamond', None), [0.95, 0.97, 0.99, 1.01, 1.03], {"Si": ['PBE', 'NC', 'sg15', 'sr']}, None)])
        sm.build("./download/pseudopotentials/", "./download/numerical_orbitals/")
        self.assertEqual(len(sm.structures), 5 * 3) # 3 is the number of pseudopotentials searched
        result = sm.export(fmt="abacus", save="unittest")
        for f in result:
            for ff in f:
                self.assertTrue(os.path.exists(ff))
                os.remove(ff)
        # test molecule
        sm.describe([('molecule', ('Si_dimer', None), [0.95, 0.97, 0.99, 1.01, 1.03], {"Si": ['PBE', 'NC', 'sg15', 'sr']}, None)])
        sm.build("./download/pseudopotentials/", "./download/numerical_orbitals/")
        self.assertEqual(len(sm.structures), 5 * 3)
        result = sm.export(fmt="abacus", save="unittest")
        for f in result:
            for ff in f:
                self.assertTrue(os.path.exists(ff))
                os.remove(ff)
        # test cif with magmom
        cif = """# generated using pymatgen
data_Ac2O
_symmetry_space_group_name_H-M   'P 1'
_cell_length_a   4.84451701
_cell_length_b   4.84451701
_cell_length_c   4.84451701
_cell_angle_alpha   60.00000000
_cell_angle_beta   60.00000000
_cell_angle_gamma   60.00000000
_symmetry_Int_Tables_number   1
_chemical_formula_structural   Ac2O
_chemical_formula_sum   'Ac2 O1'
_cell_volume   80.39637305
_cell_formula_units_Z   1
loop_
 _symmetry_equiv_pos_site_id
 _symmetry_equiv_pos_as_xyz
  1  'x, y, z'
loop_
 _atom_site_type_symbol
 _atom_site_label
 _atom_site_symmetry_multiplicity
 _atom_site_fract_x
 _atom_site_fract_y
 _atom_site_fract_z
 _atom_site_occupancy
  Ac  Ac0  1  0.75000000  0.75000000  0.75000000  1
  Ac  Ac1  1  0.25000000  0.25000000  0.25000000  1
  O  O2  1  0.00000000  0.00000000  0.00000000  1"""
        fcif = 'Ac2O.cif'
        with open(fcif, "w") as f:
            f.write(cif)
        sm.describe([('cif', (fcif, [1.0, -1.0, 0.0]), [0.95, 0.97, 0.99, 1.01, 1.03], 
                    {"Ac": ['PBE', 'NC', 'sr'], "O": ['PBE', 'GBRV', '1.5']}, None)])
        sm.build("./download/pseudopotentials/", "./download/numerical_orbitals/")
        self.assertEqual(len(sm.structures), 2 * 1 * 5) # there are 2 available pseudopotentials for Ac, 1 for O and 5 scalings
        os.remove(fcif)
        result = sm.export(fmt="abacus", save="unittest")
        for f in result:
            for ff in f:
                self.assertTrue(os.path.exists(ff))
                os.remove(ff)
