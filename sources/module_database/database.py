"""
    
"""

def get_element_label(label: int) -> str:

    element = {
        1: "H", 2: "He", 3: "Li", 4: "Be", 5: "B", 6: "C", 7: "N",
        8: "O", 9: "F", 10: "Ne", 11: "Na", 12: "Mg", 13: "Al",
        14: "Si", 15: "P", 16: "S", 17: "Cl", 18: "Ar", 19: "K",
        20: "Ca", 21: "Sc", 22: "Ti", 23: "V", 24: "Cr", 25: "Mn",
        26: "Fe", 27: "Co", 28: "Ni", 29: "Cu", 30: "Zn", 31: "Ga",
        32: "Ge", 33: "As", 34: "Se", 35: "Br", 36: "Kr", 37: "Rb",
        38: "Sr", 39: "Y", 40: "Zr", 41: "Nb", 42: "Mo", 43: "Tc",
        44: "Ru", 45: "Rh", 46: "Pd", 47: "Ag", 48: "Cd", 49: "In",
        50: "Sn", 51: "Sb", 52: "Te", 53: "I", 54: "Xe", 55: "Cs",
        56: "Ba", 57: "La", 58: "Ce", 59: "Pr", 60: "Nd", 61: "Pm",
        62: "Sm", 63: "Eu", 64: "Gd", 65: "Tb", 66: "Dy", 67: "Ho",
        68: "Er", 69: "Tm", 70: "Yb", 71: "Lu", 72: "Hf", 73: "Ta",
        74: "W", 75: "Re", 76: "Os", 77: "Ir", 78: "Pt", 79: "Au",
        80: "Hg", 81: "Tl", 82: "Pb", 83: "Bi", 84: "Po", 85: "At",
        86: "Rn", 87: "Fr", 88: "Ra", 89: "Ac", 90: "Th", 91: "Pa",
        92: "U", 93: "Np", 94: "Pu", 95: "Am", 96: "Cm", 97: "Bk",
        98: "Cf", 99: "Es", 100: "Fm", 101: "Md", 102: "No", 103: "Lr",
        104: "Rf", 105: "Db", 106: "Sg", 107: "Bh", 108: "Hs",
        109: "Mt", 110: "Ds", 111: "Rg", 112: "Cn", 113: "Nh",
        114: "Fl", 115: "Mc", 116: "Lv", 117: "Ts", 118: "Og"
    }
    return str(label) + "_" + element[label]

def get_element_index(label: str) -> int:
    
    index = {
        "H": 1, "He": 2, "Li": 3, "Be": 4, "B": 5, "C": 6, "N": 7,
        "O": 8, "F": 9, "Ne": 10, "Na": 11, "Mg": 12, "Al": 13,
        "Si": 14, "P": 15, "S": 16, "Cl": 17, "Ar": 18, "K": 19,
        "Ca": 20, "Sc": 21, "Ti": 22, "V": 23, "Cr": 24, "Mn": 25,
        "Fe": 26, "Co": 27, "Ni": 28, "Cu": 29, "Zn": 30, "Ga": 31,
        "Ge": 32, "As": 33, "Se": 34, "Br": 35, "Kr": 36, "Rb": 37,
        "Sr": 38, "Y": 39, "Zr": 40, "Nb": 41, "Mo": 42, "Tc": 43,
        "Ru": 44, "Rh": 45, "Pd": 46, "Ag": 47, "Cd": 48, "In": 49,
        "Sn": 50, "Sb": 51, "Te": 52, "I": 53, "Xe": 54, "Cs": 55,
        "Ba": 56, "La": 57, "Ce": 58, "Pr": 59, "Nd": 60, "Pm": 61,
        "Sm": 62, "Eu": 63, "Gd": 64, "Tb": 65, "Dy": 66, "Ho": 67,
        "Er": 68, "Tm": 69, "Yb": 70, "Lu": 71, "Hf": 72, "Ta": 73,
        "W": 74, "Re": 75, "Os": 76, "Ir": 77, "Pt": 78, "Au": 79,
        "Hg": 80, "Tl": 81, "Pb": 82, "Bi": 83, "Po": 84, "At": 85,
        "Rn": 86, "Fr": 87, "Ra": 88, "Ac": 89, "Th": 90, "Pa": 91,
        "U": 92, "Np": 93, "Pu": 94, "Am": 95, "Cm": 96, "Bk": 97,
        "Cf": 98, "Es": 99, "Fm": 100, "Md": 101, "No": 102, "Lr": 103,
        "Rf": 104, "Db": 105, "Sg": 106, "Bh": 107, "Hs": 108,
        "Mt": 109, "Ds": 110, "Rg": 111, "Cn": 112, "Nh": 113,
        "Fl": 114, "Mc": 115, "Lv": 116, "Ts": 117, "Og": 118
    }
    return index[label]

def sublayer_to_l(label: str):

    if label == 's':
        return 0
    elif label == 'p':
        return 1
    elif label == 'd':
        return 2
    elif label == 'f':
        return 3
    elif label == 'g':
        return 4
    else:
        raise RuntimeError("too high angular momentum")

def l_to_sublayer(l: int) -> str:

    if l == 0:
        return "s"
    elif l == 1:
        return "p"
    elif l == 2:
        return "d"
    elif l == 3:
        return "f"
    elif l == 4:
        return "g"
    else:
        raise RuntimeError("too high angular momentum")

def element_mass(label: str) -> float:
    """
    element mass, partially from NIST, National Institute of Standards and Technology
    generated by Github.copilot
    """
    mass = {
        "H": 1.00794, "He": 4.002602, "Li": 6.941, "Be": 9.012182,
        "B": 10.811, "C": 12.0107, "N": 14.0067, "O": 15.9994,
        "F": 18.9984032, "Ne": 20.1797, "Na": 22.98976928,
        "Mg": 24.305, "Al": 26.9815386, "Si": 28.0855, "P": 30.973762,
        "S": 32.065, "Cl": 35.453, "Ar": 39.948, "K": 39.0983,
        "Ca": 40.078, "Sc": 44.955912, "Ti": 47.867, "V": 50.9415,
        "Cr": 51.9961, "Mn": 54.938045, "Fe": 55.845, "Co": 58.933195,
        "Ni": 58.6934, "Cu": 63.546, "Zn": 65.409, "Ga": 69.723,
        "Ge": 72.64, "As": 74.9216, "Se": 78.96, "Br": 79.904,
        "Kr": 83.798, "Rb": 85.4678, "Sr": 87.62, "Y": 88.90585,
        "Zr": 91.224, "Nb": 92.90638, "Mo": 95.94, "Tc": 98,
        "Ru": 101.07, "Rh": 102.9055, "Pd": 106.42, "Ag": 107.8682,
        "Cd": 112.411, "In": 114.818, "Sn": 118.71, "Sb": 121.76,
        "Te": 127.6, "I": 126.90447, "Xe": 131.293, "Cs": 132.9054519,
        "Ba": 137.327, "La": 138.90547, "Ce": 140.116, "Pr": 140.90765,
        "Nd": 144.242, "Pm": 145, "Sm": 150.36, "Eu": 151.964,
        "Gd": 157.25, "Tb": 158.92535, "Dy": 162.5, "Ho": 164.93032,
        "Er": 167.259, "Tm": 168.93421, "Yb": 173.054, "Lu": 174.9668,
        "Hf": 178.49, "Ta": 180.94788, "W": 183.84, "Re": 186.207,
        "Os": 190.23, "Ir": 192.217, "Pt": 195.084, "Au": 196.966569,
        "Hg": 200.59, "Tl": 204.3833, "Pb": 207.2, "Bi": 208.9804,
        "Po": 209, "At": 210, "Rn": 222, "Fr": 223, "Ra": 226,
        "Ac": 227, "Th": 232.03806, "Pa": 231.03588, "U": 238.02891,
        "Np": 237, "Pu": 244, "Am": 243, "Cm": 247, "Bk": 247,
        "Cf": 251, "Es": 252, "Fm": 257, "Md": 258, "No": 259,
        "Lr": 262, "Rf": 261, "Db": 262, "Sg": 266, "Bh": 264,
        "Hs": 277, "Mt": 278, "Ds": 281, "Rg": 282, "Cn": 285,
        "Nh": 286, "Fl": 289, "Mc": 289, "Lv": 293, "Ts": 294,
        "Og": 294
    }
    return mass[label]

def number_to_multiplicity(n: int) -> str:

    if n == 1:
        return "s" # singlet
    elif n == 2:
        return "d" # doublet
    elif n == 3:
        return "t" # triplet
    elif n == 4:
        return "q" # quartet
    elif n == 5:
        return "p" # pentet
    elif n == 6:
        return "h" # sextet ?
    else:
        raise RuntimeError("too high multiplicity")
    
def multiplicity_to_number(m: str) -> int:

    if m == "s":
        return 1 # singlet
    elif m == "d":
        return 2 # doublet
    elif m == "t":
        return 3 # triplet
    elif m == "q":
        return 4 # quartet
    elif m == "p":
        return 5 # pentet
    elif m == "h":
        return 6 # sextet ?
    else:
        raise RuntimeError("too high multiplicity")